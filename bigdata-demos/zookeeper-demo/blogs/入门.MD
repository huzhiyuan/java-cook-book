> 为什么出现zookeeper这个东西?  

现在,应用服务变得复杂,一般由很多各种独立的程序运行在不同的机器上,程序员很容易陷入如何
让这些程序协同工作的逻辑上(就像多线程编程的时候,我们会陷入考虑并发的各种问题).  

zookeeper解决这个问题,让人们专注业务,不必担心协同问题  

> zookeeper能做什么?  

协作! 协作! 还是协作!  
分布式系统的常见场景就是一堆机器,一堆进程在协作干活! 比如主从,比如锁机制, 这类如果分布式机器
自己去实现,往往代价很高,而且不具有通用性.  

举几个例子:  
hbase: hbase中有个角色是hmaster,hmaster是通过zookeeper选举出来的,如果一台挂了,另一台会接替工作且不会丢失数据
这里面就有zk的功劳.  

kafka: zk维护了kafka的很多元数据,包括检查奔溃,topic发现,生产,消费状态等...可以想下没有zk,
kafka会乱套.  

开发人员基于zk开发的时候,开发程序其实就是zk的客户端,zk提供的客户端api功能,包含如下特性:  
1. 保障强一致性,有序性和持久性;
2. 实现通用的同步数据原语的能力;
3. zk提供了简单的并发处理机制;

> zk不适合存储海量数据, 所以切记将"应用数据"和"协同数据"独立开

典型的主-从架构:
主节点:
  1. 跟踪从节点状态;
  2. 分发任务
  3. 跟踪任务的有效性
  
主从系统面临的三个关键问题:
1. 主节点奔溃怎么办?
2. 从节点奔溃怎么办? 
3. 通信故障导致主从没法交互,怎么办?

更细化的问题：
1. 主节点挂了  
    1.1 故障转移，备节点接替工作成为新的主节点，如何恢复到崩溃前的状态。 他总不能从已经死掉的主节点
    那里获取信息吧，只能通过第三发：zk  
    1.2  “脑裂”问题，主节点没挂，但是因为网络或本身负载过高，导致从节点以为主节点挂了，
    第二个主节点开始工作。。。结果出现两个主节点，导致行为不一致。这个问题也必须解决。
      
2. 从节点挂了  
    2.1 主节点必须有能力检查从节点是否挂了  
    2.2 主节点需要确定那些正常的节点以便重新派发奔溃节点的任务  
    2.3 如果奔溃的从节点执行了一半的任务，我们还需要有机制清除之前的状态
    
3. 通信故障  
    3.1 最直接的问题：一个任务可能会被执行两次  
    3.2 对锁的影响：锁机制会影响任务的继续执行，客户端需要告诉zk某些数据是临时的，并且定时向zk汇报心跳
    ，如果zk在指定时间没收到心跳，就会把该客户端的临时数据清理掉。这两个机制可以保障客户机宕机问题
      
 > zk是分布式协同的通用解决方案，但是有些场景zk自身无法进行决策，需要开发者自己做出协作
 
 

  

 
